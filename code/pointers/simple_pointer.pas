program simple_pointer;

var
  i: integer;
  p, q: ^integer;

begin
  //"обнуление" значений указателей"
  p := nil;
  q := nil;

  //задаем значение переменной i
  i := 10;

  //p будет указывать на область памяти,
  //которую занимает i
  p := @i;

  //q будет указывать на ту же область, на которую указывает p
  q := p;

  //выводим, что содержится в ячейке памяти, на которую указывает q
  writeln(q^);

  //writeln(p); //ошибка - нельзя считывать и выводить указатели

  //указывают ли p и q на одну и ту же область памяти?
  writeln(p=q);

  ReturnNilIfGrowHeapFails := true;

  //выделяем память под значение целого типа в новой области памяти,
  //на которую будет указывать p
  new(p);

  if p = nil then
  begin
    writeln('wow... but no memory');

    halt;
  end;

  //в ячейке памяти содержится случайный "мусор"
  writeln(p^);

  //занесем значение в ячейку памяти, на которую указывает p
  p^ := 12;

  //выведем значение, содержащееся в ячейке памяти, на которую
  //ссылается p
  writeln(p^);

  //указывают ли p и q на одну и ту же область памяти?
  writeln(p=q);

  //выполним копирование значений из ячейки памяти, на которую
  //ссылается p в ячейку памяти, на которую ссылается q
  p^ := q^;

  //проверим, что хранится в p
  writeln(p^);

  //указывают ли p и q на одну и ту же область памяти?
  writeln(p=q);

  //изменим значение переменной i (той ячейки, на которую ссылается q)
  i := 13;

  //выполним присваивание адреса
  q := p;

  //проверим, что хранится в q
  writeln(q^);

  //указывают ли p и q на одну и ту же область памяти?
  writeln(p=q);

  //очищаем память, на которую указывает p
  dispose(p);

  //после очистки памяти (если работаем дальше),
  //присваиваем значение пустого указателя nil
  p := nil;

  // что будет, если попробовать еще раз освободить память?
  //try
    dispose(q);
  // except
  //  writeln('can not free memory twice!')
  //end;
end.

